# Node.js Cluster 多进程负载均衡 Demo

## 简介
本示例演示如何使用 Node.js 内置的 `cluster` 模块创建多进程服务器，充分利用多核 CPU 实现负载均衡，提升应用的并发处理能力和稳定性。

## 学习目标
- 理解 Node.js 单线程模型的局限性
- 掌握 cluster 模块的工作原理和核心 API
- 学会创建主进程（Master）与工作进程（Worker）
- 实践多进程间的通信机制
- 实现基于 CPU 核心数的自动负载均衡

## 环境要求
- Node.js >= 14.0.0（推荐使用 LTS 版本）
- 操作系统：Windows / Linux / macOS（跨平台兼容）
- 基础命令行操作能力

## 安装依赖
此项目仅使用 Node.js 内置模块，无需额外安装依赖。

```bash
# 确认 Node.js 版本
node --version
```

预期输出（版本号可能不同）：
```
v18.17.0
```

## 文件说明
- `server.js`：主服务器文件，包含 cluster 主进程和工作进程逻辑
- `simple-server.js`：对比用的单进程服务器，用于性能对照

## 逐步实操指南

### 步骤 1：启动集群模式服务器
```bash
node server.js
```

预期输出：
```
✅ 主进程 PID: 12345 已启动
🚀 创建工作进程 #1 (PID: 12346)
🚀 创建工作进程 #2 (PID: 12347)
🚀 创建工作进程 #3 (PID: 12348)
🚀 创建工作进程 #4 (PID: 12349)
...（根据CPU核心数而定）
👂 工作进程 12346 正在运行，监听端口 3000
```

### 步骤 2：访问服务测试负载均衡
打开浏览器或使用 curl 发送请求：

```bash
curl http://localhost:3000
```

多次执行，观察控制台输出，可以看到不同 Worker 进程轮流处理请求。

### 步骤 3：（可选）启动单进程服务器对比
```bash
node simple-server.js
```

## 代码解析

### `server.js` 关键代码段

```js
if (cluster.isMaster) {
  // 主进程逻辑：创建与 CPU 核心数相同的工作进程
}
```
- `cluster.isMaster` 判断是否为主进程
- `os.cpus().length` 获取 CPU 核心数，实现最优进程分配

```js
cluster.on('exit', (worker, code, signal) => { ... });
```
- 监听工作进程退出事件，自动重启崩溃的进程，保证服务高可用

```js
http.createServer((req, res) => { ... }).listen(3000);
```
- 所有工作进程共享同一个端口 3000，由操作系统内核实现负载均衡

## 预期输出示例
```
✅ 主进程 PID: 5678 已启动
🚀 创建工作进程 #1 (PID: 5679)
🚀 创建工作进程 #2 (PID: 5680)
🚀 创建工作进程 #3 (PID: 5681)
🚀 创建工作进程 #4 (PID: 5682)
👂 工作进程 5679 正在运行，监听端口 3000
👂 工作进程 5680 正在运行，监听端口 3000
```

curl 请求后：
```
📩 请求由工作进程 PID: 5679 处理
``` 

## 常见问题解答

**Q1: 为什么需要使用 Cluster？**
A: Node.js 默认是单线程，只能利用一个 CPU 核心。Cluster 可以创建多个进程，充分利用多核 CPU 提升性能。

**Q2: 多个进程监听同一端口不会冲突吗？**
A: 不会。Node.js 内部通过 IPC 和操作系统机制实现端口共享，请求由内核分发到不同进程。

**Q3: 如何知道哪个 Worker 处理了请求？**
A: 示例中打印了当前进程 PID，可通过日志区分。

**Q4: Worker 进程挂了怎么办？**
A: 主进程监听 `exit` 事件并自动重新创建新的 Worker，保障服务不中断。

## 扩展学习建议
- 使用 PM2 进程管理器替代手动 Cluster（生产环境推荐）
- 学习进程间通信（IPC）传递消息
- 结合 Redis 实现多进程共享会话（Session）
- 压力测试：使用 `ab` 或 `autocannon` 对比单进程与集群性能差异