# Go闭包编程实战演示

## 简介
本演示项目展示了Go语言中闭包（Closure）的核心概念和实际应用场景。闭包是函数与其引用环境的组合，能够捕获并访问其外部作用域中的变量，常用于状态保持、延迟执行和构建高阶函数。

## 学习目标
- 理解Go中闭包的基本语法与行为
- 掌握闭包在计数器、配置工厂和事件回调中的应用
- 学会正确使用闭包避免常见陷阱（如循环变量捕获问题）

## 环境要求
- Go 1.19 或更高版本（推荐使用稳定版）
- 操作系统：Windows、Linux 或 macOS
- 命令行终端

## 安装依赖
本项目不依赖第三方库，仅使用Go标准库，无需额外安装依赖。

## 文件说明
- `main.go`：主程序，演示闭包作为计数器的用法
- `factory.go`：展示使用闭包创建配置化工厂函数
- `callback.go`：演示闭包在模拟事件回调中的应用

## 逐步实操指南

### 步骤1：检查Go环境
运行以下命令确认Go已正确安装：
```bash
go version
```
**预期输出**：
```bash
go version go1.19+ darwin/amd64  # 版本号可能不同
```

### 步骤2：创建项目目录
```bash
mkdir go-closure-demo && cd go-closure-demo
```

### 步骤3：复制代码文件
将以下三个文件内容分别保存到对应路径：
- `main.go`
- `factory.go`
- `callback.go`

### 步骤4：运行程序
```bash
go run main.go factory.go callback.go
```

### 预期输出示例
```bash
计数器从1开始：
Count: 1
Count: 2
Count: 3

创建带前缀的日志函数：
INFO: 系统启动
ERROR: 文件未找到

模拟按钮点击事件：
按钮被点击了！用户ID: 1001
按钮被点击了！用户ID: 1002
```

## 代码解析

### main.go - 闭包计数器
```go
counter := func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}()
```
匿名函数初始化一个局部变量`count`，返回的内部函数持续引用该变量，形成闭包，实现状态持久化。

### factory.go - 工厂模式
通过闭包封装`prefix`变量，生成可复用的格式化函数，体现“数据+行为”的封装思想。

### callback.go - 回调捕获上下文
在循环中为每个事件生成独立的处理函数，正确捕获`userID`值，避免共享变量问题。

## 常见问题解答

**Q: 为什么闭包能访问外部变量？**
A: Go中闭包会捕获其词法作用域内的变量引用，即使外部函数已返回，这些变量仍保留在堆上。

**Q: 循环中使用闭包常见错误是什么？**
A: 若直接在for循环中使用循环变量（如i），所有闭包会共享同一个变量。应使用局部副本：`id := userID`。

**Q: 闭包会导致内存泄漏吗？**
A: 若闭包长期持有大对象引用且未释放，可能导致内存无法回收。应确保及时置nil或限制生命周期。

## 扩展学习建议
- 阅读《Go语言圣经》第5章“函数”
- 探索`sync.Once`、`http.HandlerFunc`等标准库中闭包的应用
- 尝试用闭包实现缓存装饰器或限流器